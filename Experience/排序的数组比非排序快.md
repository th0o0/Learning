用JAVA写的一段代码，排序的速度是非排序速度的3倍左右！
    
    
	public class Test {
	public static void main(String[] args) {
		int arraySize = 32768;
		int data[] = new int[arraySize];
		Random rn = new Random(0);
		for(int c = 0;c < arraySize;c++)
			data[c] = rn.nextInt() % 256;
		
		Arrays.sort(data);//3.462831764,不排序需要10秒多，效率提升了3倍多！
		
		long start = System.nanoTime();
		long sum = 0;
		
		for (int i = 0; i < 100000; i++) {
			for (int c = 0; c < arraySize; c++) {
				if (data[c] > 128)
					sum += data[c];
			}
		}
		long end = System.nanoTime();
		System.out.println((end - start) / 1000000000.0);
		System.out.println("sum = " + sum);
	}
	}

----------

这里面涉及到**分支预测**的问题！
----------
假设你是分叉口的操作人员，当你听到火车来了，你没法知道那一条路是正确的的，所以你的让火车停下来，问列车员那一条路是正确的，然后才转动铁路的方向。

**但是火车有很大的惯性，它的花费很长的时间来减速和开车。**

![](http://i.imgur.com/y2bxh9o.jpg)

是不是有更加好的办法呢？你可以猜测火车的前进方向

- 如果你猜对了，火车继续前进
- 如果你猜错了，火车得停下来，返回去，然后才换条路

### 当然如果你每次都猜对了，那么火车将永远不会停下来。如果猜错很多次，那么火车得停车、返回，再开车！ ###

**考虑代码中的 if 条件语句：**

	 if (data[c] > 128)
	      sum += data[c];

在处理器的层面上，这是一个分支指令，当处理器看到这个分支的时候，没办法知道将执行那个下一条语句。该怎么办呢？貌似只能暂停执行，直到前面的指令完成，然后再继续执行正确的下一条语句。现代的处理器非常复杂，因此，它需要很长的时间“热身”和“冷却”。

是不是有更加好的办法呢？你来猜测下一条的语句在哪！

- 如果你猜测对了，则继续执行。
- 如果你猜测错了，那么要返回那个出错的分支，然后才能继续。

**如果你每次都猜对**，那么你将永远不会停下来；**如果你猜错多次**，你就需要花费很多的时间来进行滚回、重启。

这就是**分支预测**。现代大多数的应用都有好的分支预测，但是在没有好的模式识别、无法预测的分支，那分支预测基本就没什么用。

----------
有了前面的铺垫，再来看代码中的if语句

	if (data[c] > 128)

代码中的数据是分布在 0到255 之间，当数据排好序之后，基本上前面一大半的数据不会进入这个条件语句，只有后面的数据才会进入到条件语句。

### 在进入同一个执行分支很多次，这对分支预测是非常友好的，可以更加准确的预测，从而带来更加高效的执行效率。 ###

**分支预测**   [https://en.wikipedia.org/wiki/Branch_predictor](https://en.wikipedia.org/wiki/Branch_predictor "分支预测")




----------
1/13/2017 3:27:42 PM 
